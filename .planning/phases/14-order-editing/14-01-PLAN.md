---
phase: 14-order-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [server/src/schemas/orders.ts, server/src/routes/orders.ts, server/src/routes/orders.test.ts]
autonomous: true
---

<objective>
Implement PATCH /orders/:id API endpoint for buyers to edit their placed orders before cutoff.

Purpose: Allow buyers to modify orders (add/remove items, change quantities, change fulfillment) while order is still in PLACED status and before batch cutoff.
Output: Working order editing API with comprehensive validation and audit logging.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@server/src/routes/orders.ts
@server/src/schemas/orders.ts
@server/src/routes/orders.test.ts
@server/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create order editing schema</name>
  <files>server/src/schemas/orders.ts</files>
  <action>
Add `editOrderSchema` to validate order edit requests:

```typescript
export const editOrderSchema = z.object({
  fulfillmentType: z.enum(['PICKUP', 'DELIVERY']).optional(),
  items: z.array(
    z.object({
      batchProductId: z.string().uuid('Batch Product ID must be a valid UUID'),
      orderedQty: z.number().nonnegative('Quantity cannot be negative'),
      // qty of 0 means remove item
    })
  ).optional(),
});
```

Export the type: `EditOrderInput`.

Note: Items array replaces all items. qty=0 means remove that item. Empty items array = cancel order.
  </action>
  <verify>TypeScript compilation succeeds: `cd server && npx tsc --noEmit`</verify>
  <done>editOrderSchema exported and usable</done>
</task>

<task type="auto">
  <name>Task 2: Implement PATCH /orders/:id endpoint</name>
  <files>server/src/routes/orders.ts</files>
  <action>
Add new route handler for `PATCH /orders/:id` with these behaviors:

**Validation:**
1. Authenticate request (use existing `authenticate` middleware)
2. Fetch order with batch included
3. Return 404 if order not found
4. Return 403 if `request.user.userId !== order.buyerId` (only owner can edit)
5. Return 400 "Order cannot be edited after payment" if `order.status !== 'PLACED'`
6. Return 400 "Batch is no longer open" if `order.batch.status !== 'OPEN'`
7. Return 400 "Batch cutoff time has passed" if `new Date(batch.cutoffAt) <= new Date()`

**Processing:**
1. Parse body with `editOrderSchema`
2. If `fulfillmentType` provided, update it
3. If `items` provided:
   - If empty array or all items have qty=0: Cancel order (set status='CANCELLED')
   - Otherwise:
     a. Validate all batchProductIds exist and are active in the batch
     b. Validate quantities against MOQ/MaxOQ
     c. Delete existing OrderItems for this order
     d. Create new OrderItems
     e. Recalculate estimatedTotal and facilitationAmt

**Transaction:**
Wrap all mutations in `prisma.$transaction`:
- Update order fields
- Delete old items (if replacing)
- Create new items (if replacing)
- Create EventLog entry:
  - If cancelled: action='ORDER_CANCELLED', metadata includes reason='User removed all items'
  - If edited: action='ORDER_EDITED', metadata includes changes summary

**Response:**
- Return updated order with items included
- Use same include pattern as GET /orders/:id
  </action>
  <verify>Manual test: Start server, place an order, then PATCH it with different items/quantities</verify>
  <done>PATCH /orders/:id works for all edit scenarios: update items, update fulfillment, cancel via empty items</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for order editing</name>
  <files>server/src/routes/orders.test.ts</files>
  <action>
Add new describe block `PATCH /orders/:id` with these test cases:

1. "should return 401 without authentication"
2. "should return 404 for non-existent order"
3. "should return 403 if user is not the order owner"
4. "should return 400 if order status is not PLACED" (test with COMMITMENT_PAID)
5. "should return 400 if batch is not OPEN"
6. "should return 400 if batch cutoff has passed"
7. "should successfully update fulfillment type"
8. "should successfully update order items"
9. "should validate MOQ for updated items"
10. "should validate MaxOQ for updated items"
11. "should cancel order when all items removed"
12. "should log ORDER_EDITED event on successful edit"
13. "should log ORDER_CANCELLED event when order cancelled"

Follow existing test patterns in the file:
- Use mockPrisma for database mocks
- Use buyerToken for authenticated requests
- Assert on response status and body
  </action>
  <verify>`npm test --workspace=server` - all tests pass</verify>
  <done>All 13 new test cases pass, existing tests still pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd server && npx tsc --noEmit` succeeds
- [ ] `npm test --workspace=server` passes all tests
- [ ] Manual test: Edit an order via curl/Postman
- [ ] Manual test: Cancel an order by sending empty items array
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- PATCH /orders/:id endpoint handles all edit scenarios
- Proper validation prevents editing after payment/cutoff
- Auto-cancel works when items emptied
- Audit logging captures edits and cancellations
</success_criteria>

<output>
After completion, create `.planning/phases/14-order-editing/14-01-SUMMARY.md`
</output>
