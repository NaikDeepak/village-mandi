---
phase: 05-batch-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/schemas/hubs.ts
  - server/src/schemas/batches.ts
  - server/src/routes/hubs.ts
  - server/src/routes/batches.ts
  - server/src/routes/hubs.test.ts
  - server/src/routes/batches.test.ts
  - server/index.ts
autonomous: true
---

<objective>
Implement Hub and Batch backend API with strict state machine enforcement and comprehensive tests.

Purpose: Establish the batch lifecycle foundation that all downstream features (pricing, orders, payments) depend on. The state machine and cutoff enforcement are business-critical.

Output: Working Hub CRUD, Batch CRUD with state transitions, audit logging, and passing test suite proving the state machine works correctly.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-batch-management/05-CONTEXT.md

# Existing patterns to follow:
@server/src/routes/farmers.ts
@server/src/routes/farmers.test.ts
@server/src/schemas/farmers.ts
@server/src/tests/helpers.ts
@server/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Hub API with Zod schemas</name>
  <files>server/src/schemas/hubs.ts, server/src/routes/hubs.ts, server/index.ts</files>
  <action>
Create Hub management following farmers.ts pattern:

**Schema (server/src/schemas/hubs.ts):**
- createHubSchema: name (min 2 chars), address (min 5 chars)
- updateHubSchema: all fields optional, isActive boolean

**Routes (server/src/routes/hubs.ts):**
- GET /hubs - list active hubs (requireAdmin)
- GET /hubs/:id - single hub (requireAdmin)
- POST /hubs - create hub (requireAdmin)
- PUT /hubs/:id - update hub (requireAdmin)
- DELETE /hubs/:id - soft delete (isActive=false) (requireAdmin)

**Register routes in server/index.ts** - add hubRoutes import and registration.

Keep it minimal - Hub is just for organizing batches by physical location.
  </action>
  <verify>curl http://localhost:3000/hubs returns 401 (auth required), POST with admin cookie creates hub</verify>
  <done>Hub CRUD works, routes registered, admin-only access enforced</done>
</task>

<task type="auto">
  <name>Task 2: Batch API with state machine and audit logging</name>
  <files>server/src/schemas/batches.ts, server/src/routes/batches.ts, server/index.ts</files>
  <action>
Create Batch management with strict state machine:

**Schema (server/src/schemas/batches.ts):**
- createBatchSchema: hubId (uuid), name (min 2), cutoffAt (ISO date string, must be future), deliveryDate (ISO date, must be after cutoff)
- updateBatchSchema: name, cutoffAt, deliveryDate (only when DRAFT)
- transitionBatchSchema: targetStatus (enum of valid next states)

**State Machine Rules (enforce in routes):**
```
VALID_TRANSITIONS = {
  DRAFT: ['OPEN'],
  OPEN: ['CLOSED'],
  CLOSED: ['COLLECTED'],
  COLLECTED: ['DELIVERED'],
  DELIVERED: ['SETTLED'],
  SETTLED: []  // Terminal state
}
```

**Additional Rules:**
- Cannot transition to OPEN if cutoffAt is in the past
- Cannot update cutoffAt/deliveryDate once batch leaves DRAFT
- Cannot skip states or go backwards

**Routes (server/src/routes/batches.ts):**
- GET /batches - list batches with optional status filter (requireAdmin)
- GET /batches/:id - single batch with hub info (requireAdmin)
- GET /batches/current - get the current OPEN batch (if any) (requireAdmin)
- POST /batches - create batch in DRAFT status (requireAdmin)
- PUT /batches/:id - update batch (only DRAFT allowed) (requireAdmin)
- POST /batches/:id/transition - transition to next state (requireAdmin)
  - Validate against VALID_TRANSITIONS
  - Log to EventLog: { entityType: 'BATCH', entityId, action: 'STATUS_CHANGE', metadata: { from, to } }
  - Return 400 with clear error if invalid transition

**Register routes in server/index.ts**

**WHY strict state machine:** Business integrity depends on predictable batch lifecycle. Orders placed against OPEN batch, payments against CLOSED, distribution against COLLECTED. Skipping states breaks downstream processes.
  </action>
  <verify>
POST /batches creates DRAFT batch
POST /batches/:id/transition with targetStatus=OPEN moves to OPEN
POST /batches/:id/transition with targetStatus=CLOSED (skip OPEN) returns 400
GET /batches?status=OPEN returns only OPEN batches
  </verify>
  <done>
Batch CRUD works, state machine enforced (no skipping, no backwards), cutoff validation works, EventLog entries created on transitions
  </done>
</task>

<task type="auto">
  <name>Task 3: Backend tests for Hub and Batch APIs</name>
  <files>server/src/routes/hubs.test.ts, server/src/routes/batches.test.ts</files>
  <action>
Create comprehensive tests following farmers.test.ts pattern:

**Hub Tests (server/src/routes/hubs.test.ts):**
- GET /hubs: 401 without auth, 403 for buyer, 200 for admin
- POST /hubs: 400 for invalid data, 201 for valid
- PUT /hubs/:id: 404 for non-existent, 200 for valid update
- DELETE /hubs/:id: soft deletes (sets isActive=false)

**Batch Tests (server/src/routes/batches.test.ts):**

*CRUD tests:*
- GET /batches: filters by status work
- GET /batches/current: returns OPEN batch or empty
- POST /batches: validates cutoffAt in future, deliveryDate after cutoff
- PUT /batches/:id: only works on DRAFT batches

*State machine tests (CRITICAL):*
- Valid transitions:
  - DRAFT → OPEN succeeds
  - OPEN → CLOSED succeeds
  - CLOSED → COLLECTED succeeds
  - COLLECTED → DELIVERED succeeds
  - DELIVERED → SETTLED succeeds

- Invalid transitions (all return 400):
  - DRAFT → CLOSED (skipping OPEN)
  - DRAFT → COLLECTED (skipping multiple)
  - OPEN → DRAFT (backwards)
  - SETTLED → anything (terminal)
  - OPEN → OPEN (no-op)

*Cutoff enforcement tests:*
- Cannot transition DRAFT → OPEN if cutoffAt is in the past

*Audit logging tests:*
- Successful transition creates EventLog entry
- EventLog contains entityType='BATCH', action='STATUS_CHANGE', metadata with from/to

Use mockPrisma from helpers.ts. Mock eventLog.create to verify audit calls.
  </action>
  <verify>cd server && npm test -- --reporter=verbose</verify>
  <done>
All tests pass:
- Hub CRUD tests pass
- Batch CRUD tests pass
- State machine validation tests pass (valid transitions succeed, invalid fail with 400)
- Cutoff enforcement tests pass
- Audit logging tests pass (EventLog created)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd server && npm test` - all tests pass
- [ ] `cd server && npm run build` - TypeScript compiles
- [ ] Manual test: create batch, transition through all states, verify EventLog entries
</verification>

<success_criteria>
- All tasks completed
- All tests pass (Hub CRUD, Batch CRUD, state machine, cutoff, audit)
- No TypeScript errors
- State machine is bulletproof: invalid transitions return 400, valid transitions work
- EventLog entries created for all state changes
</success_criteria>

<output>
After completion, create `.planning/phases/05-batch-management/05-01-SUMMARY.md`
</output>
